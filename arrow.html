<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Direction Challenge</title>
<style>
body {
  margin: 0;
  padding: 0;
  height: 100vh;
  background: linear-gradient(135deg,#dff6ff,#b5d9ff);
  font-family: Arial, sans-serif;
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
}
#arrow-title { font-size: 2rem; color: #0044aa; font-weight: 700; margin-top: 40px; margin-bottom: 20px; }
#enable-compass { background: #1976d2; color: #fff; border: none; border-radius: 12px; padding: 12px 24px; font-size: 1.1rem; font-weight: 600; cursor: pointer; margin-bottom: 20px; }
#arrow-container { width: 300px; height: 300px; display: flex; justify-content: center; align-items: center; background: linear-gradient(135deg,#e3f2fd 60%,#bbdefb 100%); border-radius: 50%; margin-bottom: 20px; }
#arrow { width: 250px; height: 250px; transform-origin: 50% 50%; }
#arrow-shape { fill: #1976d2; stroke: #0d47a1; stroke-width: 2; }
.info-row { display: flex; align-items: flex-start; justify-content: center; gap: 20px; flex-wrap: wrap; }
#crowd-container { display: flex; flex-direction: column; align-items: center; }
#crowd-square { width: 120px; height: 120px; background: linear-gradient(135deg,#e3f2fd 60%,#bbdefb 100%); border-radius: 18px; display: flex; align-items: center; justify-content: center; position: relative; }
#crowd-blobs { width: 100%; height: 100%; display: grid; grid-template-columns: repeat(15, 1fr); grid-template-rows: repeat(15, 1fr); gap: 0.5px; justify-items: center; align-items: center; }
#grid-path { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }
#grid-path polyline, #grid-path circle { stroke: #000; stroke-width: 2; fill: none; }
#grid-path circle.start { fill: #2ecc71; stroke: none; }
#grid-path circle.goal  { fill: #e74c3c; stroke: none; }
.crowd-blob { width: 4px; height: 4px; border-radius: 50%; }
#route-saying { max-width: 240px; min-height: 70px; background: linear-gradient(135deg,#e3f2fd 60%,#bbdefb 100%); border-radius: 18px; display: flex; align-items: center; justify-content: center; font-size: 1.05em; color: #1976d2; font-weight: 500; padding: 16px 18px; text-align: center; }
</style>
</head>
<body>

<h1 id="arrow-title">Walk into the direction of the arrow</h1>
<button id="enable-compass">Enable Compass</button>
<div id="arrow-container">
  <svg id="arrow" viewBox="0 0 120 120">
    <polygon id="arrow-shape" points="60,15 100,100 60,75 20,100" />
  </svg>
</div>

<div class="info-row">
  <div id="crowd-container">
    <div id="crowd-square">
      <div id="crowd-blobs"></div>
      <svg id="grid-path" viewBox="0 0 300 300" preserveAspectRatio="none"></svg>
    </div>
  </div>
  <div id="route-saying"></div>
</div>

<script>
const API_URL = "https://acidy-uncensured-lashawn.ngrok-free.dev/";
const rows = 15, cols = 15;

// ---- Heatmap ----
async function generateHeatmap() {
  try {
    const resp = await fetch(`${API_URL}get_matrix`);
    const data = await resp.json();
    const matrix = data.matrix;
    const container = document.getElementById("crowd-blobs");
    container.innerHTML = "";
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const b = document.createElement("div");
        b.className = "crowd-blob";
        const val = matrix[r][c];
        if (val === 0) b.style.background = "#66bb6a";
        else if (val === 1) b.style.background = "#ffeb3b";
        else b.style.background = "#ff5252";
        container.appendChild(b);
      }
    }
  } catch(e) { console.error(e); }
}
generateHeatmap();

// ---- Target retrieval (URL param or hash) ----
function getTarget() {
  const urlParams = new URLSearchParams(window.location.search);
  let target = urlParams.get("target") || urlParams.get("location") || urlParams.get("dest") || urlParams.get("to");
  if (!target) {
    const hash = window.location.hash?.replace(/^#/, "");
    if (hash) target = decodeURIComponent(hash);
  }
  if (!target) return null;
  return target.trim();
}
const chosenTarget = getTarget();

// ---- Route + draw path ----
let pathRC = null;
async function primeRouteAndGetPath(targetName) {
  if (!targetName) return;
  // Map input to exact LOCATION_COORDS key
  const locationMap = {
    "stage": "Stage",
    "bar 1": "Bar 1",
    "bar 2": "Bar 2",
    "entrance/exit": "Entrance/Exit",
    "foodtruck": "Foodtruck"
  };
  const mappedName = locationMap[targetName.toLowerCase()] || targetName;

  try {
    const resp = await fetch(`${API_URL}send_location`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ location: { name: mappedName } })
    });
    const data = await resp.json();
    if (data.status !== "ok") {
      document.getElementById("route-saying").textContent = data.message || "Destination not recognized.";
      return;
    }
    if (Array.isArray(data.path)) {
      pathRC = data.path;
      drawPath(pathRC);
    }
  } catch(e) { console.error(e); }
}

function drawPath(path) {
  const svg = document.getElementById("grid-path");
  svg.innerHTML = "";
  if (!path || path.length < 2) return;
  const W = 300, H = 300;
  const cellW = W / cols, cellH = H / rows;
  const points = path.map(([r,c]) => (c+0.5)*cellW + "," + (r+0.5)*cellH).join(" ");

  const poly = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
  poly.setAttribute("points", points);
  poly.setAttribute("stroke", "#000");
  poly.setAttribute("stroke-width", "2");
  poly.setAttribute("fill", "none");
  svg.appendChild(poly);

  const mk = (r,c,cls) => {
    const circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circ.setAttribute("cx", (c+0.5)*cellW);
    circ.setAttribute("cy", (r+0.5)*cellH);
    circ.setAttribute("r", Math.max(3, Math.min(cellW,cellH)*0.25));
    circ.setAttribute("class", cls);
    svg.appendChild(circ);
  };
  mk(path[0][0], path[0][1], "start");
  const last = path[path.length-1];
  mk(last[0], last[1], "goal");
}

// ---- Compass logic ----
const arrow = document.getElementById("arrow");
const enableButton = document.getElementById("enable-compass");
let currentHeading=null, displayHeading=null, currentTargetAngle=null, smoothAlpha=null;
const tolerance = 7;
let withinTarget=false, compassEnabled=false;

async function fetchNextAngle() {
  const resp = await fetch(`${API_URL}get_angle`);
  const data = await resp.json();
  if (Number(data.angle) === 999) {
    setTimeout(()=>location.href="ending.html",1000);
  } else currentTargetAngle = Number(data.angle);
}

async function registerTap() {
  await fetch(`${API_URL}tap`, {method:"POST", headers: {"Content-Type":"application/json"}, body:JSON.stringify({tap:true})});
  await fetchNextAngle();
}

enableButton.addEventListener("click", ()=>{
  if(typeof DeviceOrientationEvent!=="undefined" && typeof DeviceOrientationEvent.requestPermission==="function"){
    DeviceOrientationEvent.requestPermission().then(state=>{if(state==="granted") startCompass(); else alert("Compass access denied");});
  } else startCompass();
});

function startCompass(){
  enableButton.style.display="none";
  compassEnabled=true;
  window.addEventListener("deviceorientation",handleOrientation,true);
  requestAnimationFrame(updateArrowSmooth);
  document.body.addEventListener("click",handleTap);

  if(chosenTarget) primeRouteAndGetPath(chosenTarget);
}

function handleOrientation(e){
  let heading;
  if(e.webkitCompassHeading!==undefined) heading=e.webkitCompassHeading;
  else if(e.alpha!=null) heading=360-e.alpha;
  else return;
  if(smoothAlpha==null) smoothAlpha=heading;
  smoothAlpha=lerpAngle(smoothAlpha,heading,0.15);
  currentHeading=smoothAlpha;
}

function lerpAngle(a,b,t){
  let diff=((b-a+540)%360)-180;
  return (a+diff*t+360)%360;
}

function updateArrowSmooth(){
  if(currentHeading!=null && currentTargetAngle!=null){
    if(displayHeading==null) displayHeading=currentHeading;
    displayHeading=lerpAngle(displayHeading,currentHeading,0.25);
    const rot=currentTargetAngle-displayHeading;
    arrow.style.transform=`rotate(${rot}deg)`;
    const diff=Math.abs(((currentHeading-currentTargetAngle+540)%360)-180);
    withinTarget=diff<=tolerance;
  }
  requestAnimationFrame(updateArrowSmooth);
}

function handleTap(){if(compassEnabled && withinTarget) registerTap();}
</script>
</body>
</html>
