<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Direction Challenge</title>
<style>
/* ========== GENERAL LAYOUT ========== */
body {
  margin: 0;
  padding: 0;
  height: 100vh;
  background: linear-gradient(135deg,#dff6ff,#b5d9ff);
  font-family: Arial, sans-serif;
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* ========== TITLE ========== */
#arrow-title {
  font-size: 2rem;
  color: #0044aa;
  font-weight: 700;
  margin-top: 40px;
  margin-bottom: 20px;
  padding: 0 16px;
  box-sizing: border-box;
}

/* ========== BUTTON ========== */
#enable-compass {
  background: #1976d2;
  color: #fff;
  border: none;
  border-radius: 12px;
  padding: 12px 24px;
  font-size: 1.1rem;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 4px 10px rgba(0,0,0,.15);
  margin-bottom: 20px;
  transition: all .2s ease-in-out;
}
#enable-compass:hover {
  background: #0d47a1;
  box-shadow: 0 6px 12px rgba(0,0,0,.2);
}

/* ========== ARROW ========== */
#arrow-container {
  width: 300px;
  height: 300px;
  display: flex;
  justify-content: center;
  align-items: center;
  background: linear-gradient(135deg,#e3f2fd 60%,#bbdefb 100%);
  border-radius: 50%;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
  margin-bottom: 20px;
}

#arrow {
  width: 250px;
  height: 250px;
  transform-origin: 50% 50%;
}
#arrow-shape {
  fill: #1976d2;
  stroke: #0d47a1;
  stroke-width: 2;
}

/* ========== STATUS TEXT (HIDDEN) ========== */
#status-text {
  display: none;
}

/* ========== INFO SECTION (heatmap + text) ========== */
.info-row {
  display: flex;
  align-items: flex-start;
  justify-content: center;
  gap: 20px;
  flex-wrap: wrap;
}

#crowd-container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

#crowd-square {
  width: 120px;
  height: 120px;
  background: linear-gradient(135deg,#e3f2fd 60%,#bbdefb 100%);
  border-radius: 18px;
  box-shadow: 0 2px 12px rgba(0,0,0,0.07);
  border: 1px solid #e0ecff;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 4px;
  position: relative; /* needed for overlay */
}

#crowd-blobs {
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: repeat(15, 1fr);
  grid-template-rows: repeat(15, 1fr);
  gap: 0.5px; /* smaller gap for better fit */
  justify-items: center;
  align-items: center;
}

/* Path overlay (SVG on top of blobs) */
#grid-path {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}
#grid-path polyline, #grid-path circle {
  stroke: #000; stroke-width: 2; fill: none;
}
#grid-path circle.start { fill: #2ecc71; stroke: none; }
#grid-path circle.goal  { fill: #e74c3c; stroke: none; }

.crowd-blob {
  width: 4px;  /* small circle to fit 15x15 grid */
  height: 4px; /* small circle */
  border-radius: 50%;
}

#crowd-caption {
  font-size: 0.8rem;
  color: #1976d2;
  margin-top: 6px;
  opacity: 0.9;
}

/* Text box next to heatmap */
#route-saying {
  max-width: 240px;
  min-height: 70px;
  background: linear-gradient(135deg,#e3f2fd 60%,#bbdefb 100%);
  border-radius: 18px;
  box-shadow: 0 2px 12px rgba(0,0,0,0.07);
  border: 1px solid #e0ecff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.05em;
  color: #1976d2;
  font-weight: 500;
  padding: 16px 18px;
  text-align: center;
}

/* ========== MOBILE OPTIMIZATION ========== */
@media (max-width: 600px) {
  #arrow-title {
    font-size: 1.6rem;
    margin-top: 24px;
    margin-bottom: 16px;
    padding: 0 20px;
  }

  #arrow-container {
    width: 260px;
    height: 260px;
    margin-bottom: 20px;
  }

  #arrow {
    width: 235px;
    height: 235px;
  }

  #crowd-square {
    width: 90px;
    height: 90px;
  }

  .crowd-blob {
    width: 4px;
    height: 4px;
  }

  #route-saying {
    max-width: 180px;
    font-size: 0.95rem;
    padding: 12px 14px;
  }

  #crowd-caption {
    font-size: 0.75rem;
  }
}
</style>
</head>
<body>
  <h1 id="arrow-title">Walk into the direction of the arrow</h1>
  <button id="enable-compass">Enable Compass</button>
  <div id="arrow-container">
    <svg id="arrow" viewBox="0 0 120 120">
      <polygon id="arrow-shape" points="60,15 100,100 60,75 20,100" />
    </svg>
  </div>
  <div id="status-text">Waiting for compass...</div>

  <div class="info-row">
    <div id="crowd-container">
      <div id="crowd-square">
        <div id="crowd-blobs"></div>
        <!-- overlay for path line -->
        <svg id="grid-path" viewBox="0 0 300 300" preserveAspectRatio="none"></svg>
      </div>
      <div id="crowd-caption">heatmap of the crowd</div>
    </div>
    <div id="route-saying"></div>
  </div>

<script>
const API_URL = "https://acidy-uncensured-lashawn.ngrok-free.dev/"; // update each ngrok session
const rows = 15, cols = 15;

// ---- Route sayings
const sayings = [
  "We picked this route because it avoids the busiest areas.",
  "This way keeps you out of the densest parts of the crowd.",
  "Get there faster with a route that's 30% less crowded.",
  "Move more easily, this route is short and 15% less crowded.",
  "Save time with a path that cuts through 40% less congestion."
];
document.getElementById("route-saying").textContent =
  sayings[Math.floor(Math.random() * sayings.length)];

// ---- Heatmap generator from Python matrix
async function generateHeatmap() {
  try {
    const response = await fetch(`${API_URL}get_matrix`, {
      method: "GET",
      headers: { "ngrok-skip-browser-warning": "true" }
    });
    const data = await response.json();
    const matrix = data.matrix; // 15x15 matrix from Python
    const c = document.getElementById("crowd-blobs");
    c.innerHTML = "";
    for (let r = 0; r < rows; r++) {
      for (let col = 0; col < cols; col++) {
        const b = document.createElement("div");
        b.className = "crowd-blob";
        const val = matrix[r][col];
        if (val === 0) b.style.background = "#66bb6a";     // green
        else if (val === 1) b.style.background = "#ffeb3b"; // yellow
        else if (val > 1) b.style.background = "#ff5252";   // red
        c.appendChild(b);
      }
    }
  } catch(err) {
    console.error("Failed to fetch matrix:", err);
  }
}
generateHeatmap();

// ====== PATH OVERLAY ======
let pathRC = null; // [[row, col], ...]

async function primeRouteAndGetPath(targetName = "Stage") {
  try {
    const resp = await fetch(`${API_URL}send_location`, {
      method: "POST",
      headers: { "Content-Type": "application/json", "ngrok-skip-browser-warning": "true" },
      body: JSON.stringify({ location: { name: targetName } })
    });
    const data = await resp.json();
    if (data.status === "ok" && Array.isArray(data.path)) {
      pathRC = data.path;
      drawPathOnHeatmap(pathRC);
      console.log("Got path steps:", pathRC.length);
    } else {
      console.warn("send_location failed:", data);
    }
  } catch (e) {
    console.error("Error priming route:", e);
  }
}

function drawPathOnHeatmap(path) {
  const svg = document.getElementById("grid-path");
  if (!svg) return;
  svg.innerHTML = "";
  if (!path || path.length < 2) return;

  // SVG coordinates (viewBox 300x300)
  const W = 300, H = 300;
  const cellW = W / cols, cellH = H / rows;

  const pts = path.map(([r, c]) => {
    const x = (c + 0.5) * cellW;
    const y = (r + 0.5) * cellH;
    return `${x},${y}`;
  }).join(" ");

  const poly = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
  poly.setAttribute("points", pts);
  poly.setAttribute("stroke", "#000");
  poly.setAttribute("stroke-width", "2");
  poly.setAttribute("fill", "none");
  svg.appendChild(poly);

  // Start/goal markers
  const mk = (r, c, cls) => {
    const cx = (c + 0.5) * cellW;
    const cy = (r + 0.5) * cellH;
    const circ = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    circ.setAttribute("cx", cx);
    circ.setAttribute("cy", cy);
    circ.setAttribute("r", Math.max(3, Math.min(cellW, cellH) * 0.25));
    circ.setAttribute("class", cls);
    svg.appendChild(circ);
  };
  mk(path[0][0], path[0][1], "start");
  const last = path[path.length - 1];
  mk(last[0], last[1], "goal");
}

// ====== COMPASS LOGIC ======
const arrow = document.getElementById("arrow");
const enableButton = document.getElementById("enable-compass");
const statusText = document.getElementById("status-text");

let currentTargetAngle = null;
let currentHeading = null, displayHeading = null;
let smoothAlpha = null;
const tolerance = 7;
let withinTarget = false;
let compassEnabled = false;

// Fetch the current angle from the server
async function fetchNextAngle() {
  try {
    const response = await fetch(`${API_URL}get_angle`, {
      method: "GET",
      headers: { "ngrok-skip-browser-warning": "true" }
    });
    const data = await response.json();
    console.log("Received angle from server:", data.angle);
    if (Number(data.angle) === 999) {
      console.log("All angles completed! Going to ending page.");
      setTimeout(() => location.href = "ending.html", 1000);
    } else {
      currentTargetAngle = Number(data.angle);
    }
  } catch (err) {
    console.error("Error fetching angle:", err);
  }
}

// Send tap to server and get next angle
async function registerTap() {
  try {
    const response = await fetch(`${API_URL}tap`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "ngrok-skip-browser-warning": "true"
      },
      body: JSON.stringify({ tap: true })
    });
    const data = await response.json();
    console.log("Tap registered:", data);
    await fetchNextAngle();
  } catch (err) {
    console.error("Error registering tap:", err);
  }
}

enableButton.addEventListener("click", () => {
  if (typeof DeviceOrientationEvent !== "undefined" &&
      typeof DeviceOrientationEvent.requestPermission === "function") {
    DeviceOrientationEvent.requestPermission().then(state => {
      if (state === "granted") startCompass();
      else alert("Compass access denied");
    });
  } else startCompass();
});

function startCompass() {
  enableButton.style.display = "none";
  compassEnabled = true;
  window.addEventListener("deviceorientation", handleOrientation, true);
  requestAnimationFrame(updateArrowSmooth);
  document.body.addEventListener("click", handleTap);

  // Prime route once (also gives us the full path to draw)
  primeRouteAndGetPath("Stage").then(() => {
    // After priming, start the angle sequence
    fetchNextAngle();
  });

  // Optionally refresh heatmap periodically
  // setInterval(generateHeatmap, 1000);
}

function handleOrientation(e) {
  let heading;
  if (e.webkitCompassHeading !== undefined) heading = e.webkitCompassHeading;
  else if (e.alpha != null) heading = 360 - e.alpha;
  else return;
  if (smoothAlpha == null) smoothAlpha = heading;
  smoothAlpha = lerpAngle(smoothAlpha, heading, 0.15);
  currentHeading = smoothAlpha;
}

function lerpAngle(a, b, t) {
  let diff = ((b - a + 540) % 360) - 180;
  return (a + diff * t + 360) % 360;
}

function updateArrowSmooth() {
  if (currentHeading != null && currentTargetAngle != null) {
    if (displayHeading == null) displayHeading = currentHeading;
    displayHeading = lerpAngle(displayHeading, currentHeading, 0.25);
    const rot = currentTargetAngle - displayHeading;
    arrow.style.transform = `rotate(${rot}deg)`;
    const diff = Math.abs(((currentHeading - currentTargetAngle + 540) % 360) - 180);
    withinTarget = diff <= tolerance;
  }
  requestAnimationFrame(updateArrowSmooth);
}

function handleTap() {
  if (!compassEnabled) return;
  if (withinTarget) {
    console.log("Tap registered - user is pointing in the right direction!");
    registerTap();
  } else {
    console.log("Tap ignored - not pointing in the right direction");
  }
}
</script>
</body>
</html>
